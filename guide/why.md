# 为什么是 Vitest ？

:::tip 提示
该文档假设你熟悉 Vite 。开始阅读之前建议先浏览 [为什么选 Vite ](https://cn.vitejs.dev/guide/why.html) 和 [下一代前端工具 ViteJS ](https://www.bilibili.com/video/BV1kh411Q7WN) ， [尤雨溪](https://github.com/yyx990803)做了一个示范来解释的主要概念。
:::

## 对 Vite 原生测试运行器的需求

Vite 对常见 Web 模式开箱即用，支持 glob 导入和 SSR 等功能，而且它的许多插件和集成框架正在培育一个充满活力的生态社区。它的开发和构建模式是其成功的关键。对于文档而言，有一些基于 SSG 的替代方案，它们由 Vite 提供支持。但是 Vite 的单元测试形式还不是十分清晰，像 [Jest](https://jestjs.io/zh-Hans/) 这样的现有选项是在不同的上下文环境中创建的。 Jest 和 Vite 之间有很多重复的部分，让用户不得不创建两个不同的配置文件。

使用 Vite 开发服务器在测试期间转换您的文件，可以创建一个简单的运行程序，无需处理转换源文件的复杂性，并且可以只专注于在测试期间提供最佳 DX。使用相同配置的测试容器 (通过 `vite.config.js`)，在开发、构建和测试期间共享一个通用的转换容器。 这可以通过相同的插件 API 进行扩展，让您和您的工具与 Vite 形成完美的集成。 一开始就考虑到使用 Vite 构建的工具，利用了它在 DX 中的改进，比如它的即时热模块重载 (HMR)。 这就是 Vitest，一个由 Vite 提供支持的极速单元测试框架。

由于 Jest 的大量采用，Vitest 提供了一些兼容的API，允许大家在大多数项目中将其作为备选使用。同时还包括了进行单元测试时最常见的功能（模拟，快照以及覆盖率）。Vitest 非常注重性能，尽可能多的使用 Worker 线程进行并发运行。 并且在一些端口的测试运行速度提高了一个数量级别。浏览模式默认启用，与 Vite 推动开发者优先体验的理念保持一致。 即使在 DX 中进行了改进，Vitest 通过选择其依赖项（或直接内联所需的部分）来保持轻量级。

**Vitest 想将自己定位为 Vite 项目的首选测试运行框架，即使对于不使用 Vite 的项目也会是一个可靠的替代方案。**

继续阅读 [快速开始](./index)

## Vitest 与 X 有何不同？

你可以查看[比较](./comparisons)部分，了解有关 Vitest 与其他类似工具有何不同的更多详细信息。
